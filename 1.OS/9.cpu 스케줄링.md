# cpu 스케줄링

cpu가 하나의 프로세스 작업을 마치면 다음 프로세스 작업을 수행해야 한다. 이때 어떤 프로세스를 다음에 처리할 지 선택하는 알고리즘을 cpu scheduling 알고리즘 이라고 한다. 이러한 알고리즘은 cpu 자원을 효율적으로 사용하고 시스템 성능을 최적화하는데 중요한 역할을 한다.

## 목표

- 공정성과 효율성 유지
- 시스템의 응답 시간, 처리량, 대기 시간 최적화

## Preempive(선점형) vs Non-Preemptive(비선점형)\*\*

### 1. Preemptive

- 프로세스가 cpu를 점유하고 있는 동안 i/o나 인터럽트가 발생하지 않았음에도 다른 프로세스가 해당 cpu를 강제로 점유할 수 있다.
- 즉, 프로세스가 정상적으로 수행중인 동안 다른 프로세스가 cpu를 강제로 점유하여 실행할 수 있다.
- 선점형 스케줄링은 긴급한 작업을 신속히 처리할 수 있는 장점이 있으며, 시스템의 응답성을 높이는데 유리하다.

### 2. Non-Preemptive

- 한 프로세스가 cpu를 점유하면 i/o나 인터럽트가 발생하거나 프로세스가 종료될 때까지 다른 프로세스가 cpu를 점유하지 못한다.
- 즉, 프로세스가 스스로 cpu 사용을 끝내거나 시스템 자원 요청으로 인해 중단될 때까지 cpu를 독점적으로 사용한다.
- 비선점형 스케줄링은 프로세스가 예측 가능한 방식으로 실행되며, 스케줄링의 간결성과 안정성을 제공한다. 그러나 긴급한 작업의 처리에 있어서는 비효율적일 수 있다.

## 선점형 스케줄링 종류

### 1. SRT(Shortest Remaining Time) Scheduling

- **정의**: 가장 짧게 남은 실행 시간을 가진 프로세스를 우선적으로 수행하는 알고리즘이다.
- **동작원리**: 현재 cpu에서 실행 중인 프로세스의 남은 cpu 버스트 시간보다 더짧은 cpu 버스트 시간을 가지는 프로세스가 도착하면, cpu가 새로운 프로세스로 선점된다.
- **장점**: 평균 대기 시간을 최소화하고, 시스템의 응답 시간을 개선할 수 있다.
- **단점**: 새로운 프로세스가 자주 도착하면, 기존 프로세스가 계속해서 선점당해 **기아(Starvation) 현상**이 발생할 수 있다.
- **적용사례**: 짧은 작업을 빠르게 처리해야 하는 실시간 시스템이나 대화형 시스템에서 효과적이다.

### 2. Round Robin(RR)

- **정의**: 시분할 시스템의 성질을 활용하여 모든 프로세스가 cpu 시간을 공정하게 분배 받도록 하는 스케줄링 방법이다. 각 프로세스는 정해진 시간 동안 실행되며, 그 시간이 지나면 다음 프로세스로 넘어간다.
- **동작원리**:
  - 1. **Time Quantum 설정**: 일정 시간을 Time Quantum(Time Slice)으로 설정한다. 이 시간을 일반적으로 10~100 msec 사이의 범위를 갖는다.
  - 2. **프로세스 실행** : 준비 상태에 있는 프로세스가 정해진 Time Quantum 동안 cpu를 점유하여 실행된다.
  - 3. **대기 상태 전환**: Time Quantum이 끝나면 현재 실행 중인 프로세스는 대기 상태로 전환되고, 다음 프로세스가 실행된다.
  - 4. **순환 반복**: 모든 프로세스가 한 번씩 실행된 후, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아가서 같은 과정을 반복한다.
  - 5. **선점형 스케줄링**: 한 프로세스가 종료되기 전에 Time Quantum이 끝나면 다른 프로세스에게 cpu를 넘겨 주는 방식으로, 선점형 스케줄링의 대표적인 예다.
- **장점**:
  - **공정성**: 모든 프로세스가 동일한 시간 동안 cpu를 사용하게 되어 공정한 분배를 보장한다.
  - **반응 시간**: 짧은 Time Quantum을 사용하면 시스템의 응답 시간이 빨라지며, 사용자 인터페이스가 부드럽게 작동한다.
  - **간단한 구현**: 구현이 상대적으로 간단하고 이해하기 쉽다.
- **단점**:
  - **오버헤드**: 프로세스 전환(Context Switching)이 자주 발생하여 오버헤드가 증가할 수 있다.
  - **응답시간 증가**: Time Quantum이 너무 길면 대기 시간이 길어져 응답 시간이 느려질 수 있다.
  - **비효율성**: 프로세스가 짧은 시간 내에 끝나지 않으면 비효율적으로 동작할 수 있다.
- **적용사례**:
  - **타임 쉐어링 시스템**: 여러 사용자가 동시에 시스템을 사용하는 환경에서 공정하게 cpu 시간을 분배하기 위해 사용된다.
  - **멀티태스킹 운영체제**: 다양한 애플리케이션이 동시에 실행되는 환경에서 공정한 cpu 시간 배분을 위해 사용된다.
  - **대화형 시스템**: 사용자 명령어의 빠른 반응이 필요한 시스템에서 사용된다.

=> **Round Robin 스케줄링은 다양한 환경에서 cpu 시간을 공정하게 분배하기 위해 사용되며, 특히 사용자 인터페이스가 중요한 시스템에서 효과적으로 활용된다.**

### 3. Multilevel Queue Scheduling

- **정의**:
- **동작원리**:
- **장점**:
- **단점**:
- **적용사례**:

### 4. Multilevel Feedback Queue Scheduling

- **정의**:
- **동작원리**:
- **장점**:
- **단점**:
- **적용사례**:

## 비선점형 스케줄링 종류

### 1. FCFS (First-Come, First-Served)

- **정의**:
- **동작원리**:
- **장점**:
- **단점**:
- **적용사례**:

도착한 순서대로 프로세스를 처리한다.

### 2. SJF (Shortest Job First)

- **정의**:
- **동작원리**:
- **장점**:
- **단점**:
- **적용사례**:
