# cpu 스케줄링

cpu가 하나의 프로세스 작업을 마치면 다음 프로세스 작업을 수행해야 한다. 이때 어떤 프로세스를 다음에 처리할 지 선택하는 알고리즘을 cpu scheduling 알고리즘 이라고 한다. 이러한 알고리즘은 cpu 자원을 효율적으로 사용하고 시스템 성능을 최적화하는데 중요한 역할을 한다.

## 목표

- 공정성과 효율성 유지
- 시스템의 응답 시간, 처리량, 대기 시간 최적화

## Preempive(선점형) vs Non-Preemptive(비선점형)\*\*

### 1. Preemptive

- 프로세스가 cpu를 점유하고 있는 동안 i/o나 인터럽트가 발생하지 않았음에도 다른 프로세스가 해당 cpu를 강제로 점유할 수 있다.
- 즉, 프로세스가 정상적으로 수행중인 동안 다른 프로세스가 cpu를 강제로 점유하여 실행할 수 있다.
- 선점형 스케줄링은 긴급한 작업을 신속히 처리할 수 있는 장점이 있으며, 시스템의 응답성을 높이는데 유리하다.

### 2. Non-Preemptive

- 한 프로세스가 cpu를 점유하면 i/o나 인터럽트가 발생하거나 프로세스가 종료될 때까지 다른 프로세스가 cpu를 점유하지 못한다.
- 즉, 프로세스가 스스로 cpu 사용을 끝내거나 시스템 자원 요청으로 인해 중단될 때까지 cpu를 독점적으로 사용한다.
- 비선점형 스케줄링은 프로세스가 예측 가능한 방식으로 실행되며, 스케줄링의 간결성과 안정성을 제공한다. 그러나 긴급한 작업의 처리에 있어서는 비효율적일 수 있다.

## 선점형 스케줄링 종류

### 1. SRT(Shortest Remaining Time) Scheduling

- **정의**: 가장 짧게 남은 실행 시간을 가진 프로세스를 우선적으로 수행하는 알고리즘이다.
- **동작원리**: 현재 cpu에서 실행 중인 프로세스의 남은 cpu 버스트 시간보다 더짧은 cpu 버스트 시간을 가지는 프로세스가 도착하면, cpu가 새로운 프로세스로 선점된다.
- **장점**: 평균 대기 시간을 최소화하고, 시스템의 응답 시간을 개선할 수 있다.
- **단점**: 새로운 프로세스가 자주 도착하면, 기존 프로세스가 계속해서 선점당해 **기아(Starvation) 현상**이 발생할 수 있다.
- **적용사례**: 짧은 작업을 빠르게 처리해야 하는 실시간 시스템이나 대화형 시스템에서 효과적이다.

### 2. Round Robin(RR)

- **정의**: 시분할 시스템의 성질을 활용하여 모든 프로세스가 cpu 시간을 공정하게 분배 받도록 하는 스케줄링 방법이다. 각 프로세스는 정해진 시간 동안 실행되며, 그 시간이 지나면 다음 프로세스로 넘어간다.
- **동작원리**:
  - 1. **Time Quantum 설정**: 일정 시간을 Time Quantum(Time Slice)으로 설정한다. 이 시간을 일반적으로 10~100 msec 사이의 범위를 갖는다.
  - 2. **프로세스 실행** : 준비 상태에 있는 프로세스가 정해진 Time Quantum 동안 cpu를 점유하여 실행된다.
  - 3. **대기 상태 전환**: Time Quantum이 끝나면 현재 실행 중인 프로세스는 대기 상태로 전환되고, 다음 프로세스가 실행된다.
  - 4. **순환 반복**: 모든 프로세스가 한 번씩 실행된 후, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아가서 같은 과정을 반복한다.
  - 5. **선점형 스케줄링**: 한 프로세스가 종료되기 전에 Time Quantum이 끝나면 다른 프로세스에게 cpu를 넘겨 주는 방식으로, 선점형 스케줄링의 대표적인 예다.
- **장점**:
  - **공정성**: 모든 프로세스가 동일한 시간 동안 cpu를 사용하게 되어 공정한 분배를 보장한다.
  - **반응 시간**: 짧은 Time Quantum을 사용하면 시스템의 응답 시간이 빨라지며, 사용자 인터페이스가 부드럽게 작동한다.
  - **간단한 구현**: 구현이 상대적으로 간단하고 이해하기 쉽다.
- **단점**:
  - **오버헤드**: 프로세스 전환(Context Switching)이 자주 발생하여 오버헤드가 증가할 수 있다.
  - **응답시간 증가**: Time Quantum이 너무 길면 대기 시간이 길어져 응답 시간이 느려질 수 있다.
  - **비효율성**: 프로세스가 짧은 시간 내에 끝나지 않으면 비효율적으로 동작할 수 있다.
- **적용사례**:
  - **타임 쉐어링 시스템**: 여러 사용자가 동시에 시스템을 사용하는 환경에서 공정하게 cpu 시간을 분배하기 위해 사용된다.
  - **멀티태스킹 운영체제**: 다양한 애플리케이션이 동시에 실행되는 환경에서 공정한 cpu 시간 배분을 위해 사용된다.
  - **대화형 시스템**: 사용자 명령어의 빠른 반응이 필요한 시스템에서 사용된다.

=> **Round Robin 스케줄링은 다양한 환경에서 cpu 시간을 공정하게 분배하기 위해 사용되며, 특히 사용자 인터페이스가 중요한 시스템에서 효과적으로 활용된다.**

### 3. Multilevel Queue Scheduling

- **정의**: 프로세스를 여러 그룹으로 나눠어 각 그룹에 따른 여러 개의 Ready Queue를 두고, 각 큐마다 다른 스케줄링 규칙을 지정할 수 있는 스케줄링 기법이다.

- **동작원리**:

  - 프로세스들은 그 특성에 따라 특정 그룹으로 분류되며, 해당 그룹에 할당된 큐에 들어간다.
  - 각 큐는 우선순위, cpu 시간 등의 기준에 따라 다른 스케줄링 규칙을 적용받는다.
  - 프로세스가 cpu를 기다릴 때, 한 줄이 아닌 여러 줄로 나누어 대기한다.
  - 일반적으로 높은 우선순위의 큐가 먼저 스케줄링되며, 낮은 우선순위의 큐는 높은 우선순위 큐가 비어있을 때만 스케줄링된다.

- **장점**:
  - 프로세스의 특성에 따라 효율적으로 스케줄링할 수 있다.
  - 각 큐마다 다른 스케줄링 규칙을 적용할 수 있어 유연성이 높다.
  - 중요한 작업을 우선 처리할 수 있어 응답 시간을 단축시킬 수 있다.
- **단점**:
  - 큐 간의 우선순위 설정이 복잡할 수 있다.
  - 낮은 우선순위 큐에 있는 프로세스는 기아 상태에 빠질 수 있다.
  - 전체 시스템의 스케줄링 정책이 복잡해질 수 있다.
- **적용사례**:
  - 시스템 프로세스와 사용자 프로세스를 분리하여 관리하는 경우.
  - 실시간 시스템에서 실시간 프로세스와 비실시간 프로세스를 구분하여 스케줄링하는 경우.
  - 대화형 작업과 매치 작업을 분리하여 각기 다른 스케줄링을 적용하는 경우.

### 4. Multilevel Feedback Queue Scheduling

- **정의**: Multilevel Queue Scheduling의 개념을 확장한 것으로, 프로세스가 하나의 큐에서 다른 큐로 이동할 수 있는 스케줄링 기법이다.

- **동작원리**:

  - 프로세스는 초기에는 높은 우선순위 큐에 배치된다.
  - 프로세스가 cpu를 사용한 시간이 길어질수록 낮은 우선순위 큐로 이동하게 된다.
  - 반대로, 오랫동안 실행되지 못한 프로세스는 더 높은 우선순위 큐로 이동될 수 있다.
  - 각 큐는 자체의 스케줄링 규칙을 가지며, 주로 높은 우선순위 큐는 짧은 시간 할당량과 빠른 응답 시간을 목표로 한다.
  - 시스템은 주기적으로 또는 특정 이벤트에 의해 프로세스의 위치를 재평가하고 큐를 변경할 수 있다.

- **장점**:

  - 프로세스가 유연하게 큐 사이를 이동할 수 있어 cpu 자원을 보다 효율적으로 사용할 수 있다.
  - 오래 대기한 프로세스는 우선순위가 상승하여 기아 상태를 방지할 수 있다.
  - 다양한 작업 부하를 효과적으로 처리할 수 있어 시스템 성능이 향상된다.

- **단점**:

  - 스케줄링 정책이 복잡하고 관리하기 어려울 수 있다.
  - 적절한 시간 할당량과 우선순위 조정이 필요하며, 이를 잘못 설정할 경우 성능 저하가 발생할 수 있다.
  - 시스템 오버헤드가 증가할 수 있다.

- **적용사례**:
  - 다양한 우선순위의 작업을 동시에 처리해야 하는 운영체제 환경.
  - 대화형 시스템에서 사용자 응답 시간을 최소화하면서 배치 작업도 효율적으로 처리해야 하는 경우.
  - 실시간 시스템에서 실시간 요구 사항과 일반 작업을 균형 있게 처리해야 하는 경우.

## 비선점형 스케줄링 종류

### 1. FCFS (First-Come, First-Served)

- **정의**: 준비 Queue에 먼저 도착한 프로세스가 먼저 cpu를 점유하는 스케줄링 방식이다.

- **동작원리**:

  - 프로세스가 준비 Queue에 도착하는 순서대로 cpu를 할당받는다.
  - 한번 cpu를 할당받은 프로세스는 cpu burst가 완료될 때까지 cpu를 반환하지 않는다.
  - cpu가 반환될 때만 새로운 스케줄링이 이루어진다.

- **예제**:
  표는 3개의 프로세스와 각 프로세스의 cpu 사용 시간(burst time)을 나타낸다.

프로세스 | Burst Time
p1 | 24
p2 | 3
p3 | 3

- 프로세스들이 p1, p2, p3 순서로 들어온 경우:
  - 간트 차트 : `P1 (24msec) -> P2 (3msec) -> P3 (3msec)`
  - 평균 대기 시간 : (0+24+27)/3 = 17msec
- 프로세스들이 p3, p2, p1 순서로 들어온 경우:

  - 간트 차트 : `P3 (3msec) -> P2 (3msec) -> P1 (24msec)`
  - 평균 대기 시간 : (0+3+6)/3 = 3msec

- **분석**:

  - 두 경우 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기 시간은 첫번째 경우 17msec, 두번째 경우 3msec로 차이가 난다.
  - 들어온 순서대로 수행한다고 해서 항상 효율적인 것은 아니다.

- **Convoy Effect**:

  - 프로세스가 p1, p2, p3 순서로 들어온 경우, p1이 cpu 시간을 오래 사용하면 p2, p3은 오래 기다려야 한다.
  - 이는 Convoy Effect라 불리며, cpu 시간을 많이 사용하는 프로세스가 먼저 수행될 때 발생한다.
  - p1이 수행되는 동안 p2,p3는 오랫동안 대기하게 된다.

- **장점**:

  - 구현이 간단하고 이해하기 쉬움.
  - 선입선출 방식으로 공정하게 cpu를 할당함.

- **단점**:

  - Convoy Effect 발생: 소요 시간이 긴 프로세스가 먼저 도착하면 뒤에 프로세스들이 오래 기다려야 함.
  - 평균 대기 시간이 길어질 수 있음.
  - 비선점형 방식이므로 실시간 시스템에 적합하지 않음.

- **적용사례**:
  - 간단한 배치 처리 시스템
  - 초기 컴퓨터 시스템에서 주로 사용됨
  - cpu와 i/o 작업이 고르게 분포된 환경에서 적절함

### 2. SJF (Shortest Job First)

- **정의**:
  : SJF는 다른 프로세스가 먼저 도착했더라도 CPU 버스트가 짧은 프로세스에게 CPU를 먼저 할당하는 방식이다. 선점형과 비선점형 모두 가능하다.

- **동작원리**:

  - 프로세스들이 CPU를 사용하고자 할 때, 가잘 짧은 CPU 버스트 시간을 가진 프로세스가 우선적으로 CPU를 할당받는다.
  - 선점형 SJF는 현재 실행 중인 프로세스보다 더 짧은 CPU 버스트 시간을 가진 새로운 프로세스가 도착하면 CPU를 선점하여 해당 프로세스에게 할당한다.

- **예제**

  - 간트 차트를 사용하여 SJF 스케줄링을 설명한다.

프로세스 | Burst Time
p1 | 6
p2 | 8
p3 | 7
p4 | 3

1. SJF를 사용한 경우

- 프로세스 도착 순서 : P1, P2, P3, P4
- CPU 버스트 시간 : P1(6ms), P2(8ms), P3(7ms), P4(3ms)
- 간트 차트: P4(3ms) > P1(6ms) > P3(7ms) > P2(8ms)
- 평균 대기 시간 : (0+3+9+16)/4 = 7ms

2. FCFS를 사용한 경우

- 프로세스 도착 순서: P1, P2, P3, P4
- 간트 차트: P1 > P2 > P3 > P4
- 평균 대기 시간 : (0+6+14+21)/4 = 20.25ms

- **분석**:

  - SJF는 FCFS보다 평균 대기 시간이 짧다.
  - 수학적으로 증명되었으며, 대부분의 예제에서도 SJF의 평균 대기 시간이 더 짧다는 것을 알 수 있다.

- **단점**:
  - SJF는 실제 컴퓨터 환경에서 구현하기 어렵다. 프로세스의 CPU 버스트 시간을 미리 알 수 업식 때문이다.
  - CPU 점유 시간을 예측하려면 실제로 프로세스를 실행해봐야 하는데, 이는 오버헤드가 매우 큰 작업이다.
  - 정확한 예측이 어려워 실제로 잘 사용되지 않는다.

### 3. Priority

- **정의**: 우선순위가 높은 프로세스가 먼저 선택되는 스케줄링 알고리즘이다. 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다 (unix/linux기준)
- 선점형과 비선점형 모두 가능하다.
- **동작원리**:
  - 각 프로세스는 우선순위 값을 가지며, 우선순위가 높은 프로세스가 cpu를 먼저 할당받는다.
  - 새로운 프로세스가 도착하면 현재 실행 중인 프로세스보다 우선순위가 높을 경우 cpu를 선점한다.
- **예제**:

  - 간트 차트를 사용하여 우선순위 스케줄링을 설명한다.

- **간트 차트**:
  프로세스 | Burst Time | Priority
  p1 | 10 | 3
  p2 | 1 | 1
  p3 | 2 | 4
  p4 | 1 | 5
  p5 | 5 | 2

  - 우선순위가 낮은 순서대로 수행:
    - 프로세스 도착 순서

- **우선순위 결정 요소**:
  - 내부적 요소: time limit, memory requirement, I/O to CPU burst(I/O 작업은 길고, CPU 작업은 짧은 프로세스 우선) 등
  - 외부적 요소: amout of funds being paid, political factors 등
- **단점**:

  - starvation 현상: 우선순위가 매우 낮은 프로세스가 cpu를 오랫동안 할당받지 못하는 현상.
  - 새로운 프로세스가 자주 도착하면 낮은 우선순위 프로세스는 계속 대기 상태에 있을 수 있다.

- **해결 방법**:

  - **Aging**: 대기 시간이 길어질수록 우선순위를 점진적으로 높여주는 방법.
    - 일정 시간이 지나면 우선순위를 높여, 기다리는 시간이 길어질수록 수행될 가능성이 커진다.

- **적용사례**:
  - 실시간 시스템에서 중요한 작업을 우선 처리해야 할 때.
  - 다양한 우선순위의 작업을 동시에 처리해야 하는 운영체제 환경.
