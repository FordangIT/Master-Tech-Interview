# 교착 상태 (DeadLock)

## 정의

- 한정된 자원을 여러 프로세스가 사용하려고 할 때 발생하는 문제이다.
- 즉, 프로세스가 필요한 자원을 얻지 못해서 다음 처리를 하지 못하는 상태이다.

## 예시 (그림참고)

프로세스 1과 프로세스 2가 모두 자원 1, 자원 2를 얻어야 한다고 가정해보자.

t1: 프로세스 1이 자원 1을 얻음/ 프로세스 2가 자원2를 얻음.
t2: 프로세스 1은 자원 2를 기다림/ 프로세스 2는 자원 1 을 기다림

현재 서로 원하는 자원이 상대방에게 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠지게 된다.
=> `DeadLock`

## 발생 조건

- 교착 상태가 발생하기 위해서는 네가지 조건이 모두 만족되어야 한다.
  **1. 상호배제 (Mutual Exclusion)**
  : 자원은 한번에 한 프로세스만 사용할 수 있어야 한다.
  **2. 점유와 대기 (Hold and Wait)**
  :최소한 하나의 자원을 점유하고 있는 프로세스가 다른 프로세스에 할당되어 사용하고 있는 자원을 추가적으로 요구하며 대기해야 한다.
  **3. 비선점 (No Preemption)**
  : 다른 프로세스에 할당된 자원을 강제로 빼앗을 수 없어야 한다.  
  **4. 순환 대기 (Circular Wait)**
  : 자원을 기다리는 프로세스들이 원형으로 연결되어 있어야 한다.

## 주로 발생하는 경우

- **한정된 자원 경쟁**: 멀티 프로그래밍 환경에서 여러 프로세스가 한정된 자원을 얻기 위해 경쟁한다. 예를 들어, 프린터, 파일, 데이터베이스와 같은 자원이 동시에 여러 프로세스에 의해 사용될 수 없는 경우, 자원 경쟁이 발생한다.
- **자원 요청과 대기**: 프로세스가 자원을 요청할 때 해당 자원이 이미 다른 프로세스에 의해 사용 중이라면, 해당 프로세스는 대기 상태로 들어간다. 이때, 대기 중인 프로세스는 요청한 자원이 해제되기를 기다린다.

## 교착 상태 처리

### 1. 교착 상태 예방

- 시스템이 교착 상태에 빠지지 않도록 사전에 조치를 취하는 방법이다.
- 교착 상태가 발생하는 4가지 조건 중 하나를 제거하여 해결한다.
- 자원의 낭비가 심할 수 있다는 단점이 있지만, 확실한 예방책이다.

**1.상호 배제 부정**
**설명**: 상호 배제는 자원이 한번에 하나의 프로세스만 사용할 수 있는 조건이다.

**해결방법**: 여러 프로세스가 동시에 자원을 공유할 수 있도록 한다. 예를 들어, 읽기 전용 자원에 대해 여러 프로세스가 동시에 접근할 수 있도록 허용한다.

**단점**: 일부 자원은 본질적으로 상호 배제를 필요로 하기 때문에 완전히 제거하기 어렵다.

**2.점유 대기 부정**
**설명**: 점유 대기는 프로세스가 이미 자원을 점유하고 있는 상태에서 추가 자원을 요청하며 대기하는 조건이다.
**해결 방법**: 프로세스가 실행되기 전에 필요한 모든 자원을 한 번에 할당한다. 이렇게 하면 실행 중인 프로세스는 추가 자원을 요청할 필요가 없다.
**단점**: 자원이 비효율적으로 사용될 수 있으며, 다른 프로세스가 필요한 자원을 오랫동안 점유할 수 있다.

**3.비선점 부정**
**설명**: 비선점은 프로세스가 자원을 점유한 상태에서 강제로 빼앗기지 않는 조건이다.
**해결 방법**: 프로세스가 다른 자원을 요구할 때, 이미 점유 중인 자원을 반납하도록 한다. 이후 필요한 자원을 사용할 수 있게 되면 다시 요청할 수 있다.
**단점**: 자원을 반납하는 과정에서 작업이 중단될 수 있으며, 다시 자원을 할당받을 때까지 대기해야 하는 비효율이 발생할 수 있다.

**4. 순환 대기 부정**
**설명**: 순환 대기는 프로세스들이 서로의 자원을 기다리며 순환적으로 대기하는 조건이다.
**해결 방법**: 자원에 고유한 번호를 할당하고, 프로세스가 자원을 요청할 때 항상 증가하는 순서대로 자원을 요청하도록 한다. 예를 들어, 프로세스가 자원 1을 점유한 상태에서 자원 2 를 요청할 수 있지만, 반대로 자원 2 를 점유한 상태에서 자원 1 을 요청할 수 없다.
**단점**: 자원 요청 순서를 정하는 데 추가적인 관리와 복잡성이 필요할 수 있다.

#### 교착 상태 예방의 단점

**자원 낭비**: 필요한 모든 자원을 미리 할당하는 방법은 자원의 비효율적 사용을 초래할 수 있다.  
**복잡성 증가**: 자원 번호를 할당하고 순서대로 요청하게 하는 등의 방법은 시스템의 복잡성을 증가시킬 수 있다.
**프로세스 지연**: 자원을 반납하고 다시 요청하는 과정에서 프로세스가 지연될 수 있다.

### 2. 교착 상태 회피

: 교착 상태 회피는 교착 상태를 사전에 피할 수 있도록 하는 기법으로, 프로세스가 자원을 요구할 때 시스템이 현재 상태와 자원 요청을 검토하여 교착 상태로 이어질 가능성이 있는지 판단하는 방식이다. 가장 대표적인 방법으로는 다익스트라가 제안한 `은행원 알고리즘`이 있다.

#### 은행원 알고리즘

**개요**

- 은행가 알고리즘은 은행에서 모든 고객의 요구를 충족하도록 현금을 할당하는 데서 유래한 기법이다.
- 시스템은 자원을 할당하기 전에 자원 할당 후에도 시스템이 안전 상태로 남아 있는지를 검사한다.

**안전 상태**

- 시스템이 어떤 프로세스에 자원을 할당한 후에도 교착 상태 없이 모든 프로세스가 완료될 수 있는 상태를 말한다.
- 안전 상태에서는 어떤 순서로든 프로세스가 자원을 획득하고 작업을 완료한 후 자원을 해제할 수 있다. 키

#### 은행원 알고리즘 동작 원리

**1. 자원 상태 정보 유지**:

- 시스템은 현재 자원 상태, 각 프로세스의 최대 요구량, 이미 할당된 자원, 그리고 아직 필요한 자원 정보를 유지한다.
  **2. 자원 요청 시 검사**:
- 프로세스가 자원을 요청하면 시스템은 이 시스템이 안전 상태로 유지될 수 있는지를 검토한다.
  **3. 안전성 검사**:
- 자원을 할당한 후에도 시스템이 안전 상태로 남아 있는지 확인한다. 이를 위해 가상의 자원 할당을 수행한 후, 모든 프로세스가 순서대로 완료될 수 있는지를 검사한다.
- 만약 자원 할당 후에도 안전 상태가 유지되면 자원을 실제로 할당한다.
- 그렇지 않으면 해당 프로세스의 자원 요청을 거부하거나 대기시킨다.

#### 교착 상태 회피의 장점과 단점

**장점**:

- 교착 상태가 발생하지 않도록 사전에 방지할 수 있다.
- 자원의 효율적인 사용이 가능하다.

**단점**:

- 모든 자원 상태와 요구를 지속적으로 추적하고 계산해야 하므로 오버헤드가 발생할 수 있다.
- 시스템의 복잡성이 증가하며, 프로세스의 자원 요구량을 사전에 정확히 알아야 한다.

### 3. 교착 상태 탐지

: 교착 상태를 잠지하는 주요 방법 중 하나는 `자원 할당 그래프`를 사용하는 것이다.

(그림2 참고)
**자원 할당 그래프는** 시스템 내의 자원 할당 상태를 나타내는 그래프로, 노드(프로세스, 자원)와 엣지로 구성된다.

- P => R (P가 R자원 요청)
- R => P (P에 R자원 할당)

**교착 상태 탐지 과정**

- **사이클 탐지:**
  - 자원 할당 그래프에서 **사이클**의 존재 여부를 검사한다. 사이클이 있으면, 그 사이클에 포함된 프로세스들이 교착 상태에 빠진 것으로 간주된다.
  - 이런 사이클 탐지는 그래프 탐색 알고리즘(dfs, bfs)을 사용하여 수행된다.

**오버헤드 문제**

- 교착 상태 탐지 알고리즘은 매 자원 요청마다 실행되어야 하므로, 시스템에 상당한 오버헤드를 초래할 수 있다.
- 특히 자원과 프로세스의 수가 많은 대규모 시스템에서는 이 오버헤드가 더욱 두드러진다.

**중요성**

- 시스템의 안전성과 효율성 유지
- 교착 상태가 발생하면 해당 프로세스들이 무한 대기 상태에 빠져 시스템 자원이 낭비되고, 시스템 성능이 저하될 수 있다.
- 시스템 신뢰성 높인다.

### 4. 교착 상태 회복

교착 상태 회복은 시스템이 교착 상태에 빠진 후 이를 해결하는 과정을 의미한다. 이는 주로 **프로세스의 종료**나 **자원 선점**을 통해 이루어진다.

**1. 프로세스 종료**
교착 상태를 해결하기 위해 프로세스를 죵료하는 방법이고, 두가지 접근 방식을 포함한다.

- **모든 교착 상태 프로세스 종료**:
  - 가장 확실하지만 가장 과격한 방법
  - 모든 교착 상태에 연루된 프로세스를 일괄적으로 종료함으로써 교착 상태를 즉각적으로 해소
  - 진행 중이던 작업의 손실이 크다는 단점이 있다.
- **한 프로세스씩 종료**:
  - 교착 상태가 해소될 때까지 순차적으로 프로세스를 하나씩 종료하는 방법
  - 필요한 최소한의 프로세스만 종료하여 작업 손실을 최소화할 수 있다.
  - 하지만, 어떤 프로세스 종료할지 결정하는 과정에서 시간 소요된다.

**2. 자원 선점**
교착 상태에 연루된 프로세스로부터 **자원을 강제로 회수**하고, 이를 **다른 프로세스에게 재할당함**으로써 교착 상태를 해소하는 방법이다. 두가지 방식으로 진행될 수 있다.

- **우선순위가 낮은 프로세스에서 선점**
  - 시스템 정책에 따라 우선순위가 낮은 프로세스의 자원을 먼저 선점한다.
  - 이 방식은 우선순위가 높은 작업을 보호하는데 유리하다.
- **실행 횟수가 적은 프로세스에서 선점**:
  - 덜 중요하거나 실행 횟수가 적은 프로세스로부터 자원을 선점한다.
  - 자원 사용이 많고 중요한 프로세스의 작업을 방해하지 않으려는 목적

## 주요 질문

Q. 교착 상태가 무엇이고, 발생 조건에 대해 설명해주세요
Q. 회피 기법인 은행원 알고리즘에 대해 설명해주세요
Q. 기아 상태를 설명하는 "식사하는 철학자 문제"에 대해 설명해주세요

## 식사하는 철학자 문제

: 복수의 프로세스(철학자)가 공유 자원(젓가락)에 대한 접근을 요구할 때 발생할 수 있는 `교착 상태`와 `기아 상태`를 설명하는 고전적인 컴퓨터 과학 문제다. 철학자들은 식사와 사색을 반복하며, 식사를 하기 위해서는 양 옆에 있는 두 젓가락을 모두 사용해야 한다.
아래와 같은 방법으로 교착 상태와 기아 상태를 해결할 수 있다.

### 1. 철학자 수 제한

- **n명이 앉을 수 있는 테이블에서 n-1명만 앉게함**:테이블에 한 자리를 비워두면, 젓가락이 부족한 상황을 방지할 수 있습니다. 이 방법은 항상 한 명의 철학자가 식사를 마칠 수 있도록 보장하므로, 순차적으로 모든 철학자가 식사할 기회를 가질 수 있습니다.

### 2. 젓가락 획득 규칙 변경

- **한 철학자가 젓가락 두 개를 모두 집을 수 있는 상황에서만 젓가락을 집도록 허용**: 이 규칙은 철학자가 한 쪽 젓가락만 집고 기다리는 상황을 방지합니다. 철학자는 양쪽 젓가락을 동시에 사용할 수 있을 때만 식사를 시작할 수 있으므로, 교착 상태 발생 확률을 감소시킵니다.

### 3. 젓가락 집는 순서 변경

- **누군가는 왼쪽 젓가락을 먼저 집지 않고 오른쪽 젓가락을 먼저 집도록 허용**: 일반적으로 모든 철학자가 왼쪽 젓가락을 먼저 집는 규칙을 따르는 경우, 동시에 모두가 왼쪽 젓가락을 집으려 할 때 교착 상태가 발생할 수 있습니다. 이를 방지하기 위해 일부 철학자에게는 오른쪽 젓가락부터 집도록 하여, 젓가락 집는 패턴을 비대칭적으로 만듭니다. 이 방식은 교착 상태를 효과적으로 방지할 수 있습니다.
